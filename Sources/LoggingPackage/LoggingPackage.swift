// Logging Package
//
// https://github.com/StasonLV/LoggingPackage

import OSLog

protocol LoggingInterface {
    static func log(
        for category: Categories,
        with message: String,
        priority level: OSLogType,
        file: String,
        function: String,
        line: Int,
        appendToFile: Bool
    )
}

final public class Logging: LoggingInterface {
    
    private static var subsystem: String! {
        didSet {
            makeLoggers()
        }
    }
    private static let sharedInstance: Logging = {
        let instance = Logging()
        subsystem = Bundle.main.bundleIdentifier ?? "undefinedSubsystemBundle"
        return instance
    }()

    private static var networkLogger: Logger?
    private static var viewcycleLogger: Logger?
    private static var userInterfaceLogger: Logger?
    private static var statisticsLogger: Logger?
    private static var privateFileLogger: Logger?
    private static var socketLogger: Logger?
    
    init() {
        Logging.subsystem = Bundle.main.bundleIdentifier ?? "undefinedSubsystemBundle"
        print("Logger INITIALIZED")
    }
    
    deinit {
        Logging.log(for: .privateFileLogging, with: "LOGGER DEINITIALIZED", priority: .fault)
        print("Logger DEINITIALIZED")
    }
    ///  –°–æ–∑–¥–∞–µ–º –ª–æ–≥–≥–µ—Ä—ã –¥–ª—è –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ —Ñ—É–Ω–∫—Ü–∏–∏ log()(–º–µ—Ç–æ–¥ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π).
    ///
    private static func makeLoggers() {
        Logging.networkLogger = Logger(subsystem: subsystem, category: Categories.networkLogging.rawValue)
        Logging.viewcycleLogger = Logger(subsystem: subsystem, category: Categories.viewcycleLogging.rawValue)
        Logging.userInterfaceLogger = Logger(subsystem: subsystem, category: Categories.userInterfaceLogging.rawValue)
        Logging.statisticsLogger = Logger(subsystem: subsystem, category: Categories.statisticsLogging.rawValue)
        Logging.privateFileLogger = Logger(subsystem: subsystem, category: Categories.privateFileLogging.rawValue)
        Logging.socketLogger = Logger(subsystem: subsystem, category: Categories.socketLogging.rawValue)
    }
    ///  –ü–æ–ª—É—á–∞–µ–º –ª–æ–≥–≥–µ—Ä –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏(–º–µ—Ç–æ–¥ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π).
    ///
    /// - Parameters:
    ///   - category: –∫–∞—Ç–µ–≥–æ—Ä–∏—è –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
    private static func getLogger(for category: Categories) -> Logger {
        switch category {
        case .viewcycleLogging:
            return viewcycleLogger ?? Logger(subsystem: subsystem, category: category.rawValue)
        case .userInterfaceLogging:
            return userInterfaceLogger ?? Logger(subsystem: subsystem, category: category.rawValue)
        case .networkLogging:
            return networkLogger ?? Logger(subsystem: subsystem, category: category.rawValue)
        case .statisticsLogging:
            return statisticsLogger ?? Logger(subsystem: subsystem, category: category.rawValue)
        case .privateFileLogging:
            return privateFileLogger ?? Logger(subsystem: subsystem, category: category.rawValue)
        case .socketLogging:
            return socketLogger ?? Logger(subsystem: subsystem, category: category.rawValue)
        }
    }
    
    private static let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss"
        return formatter
    }()
    ///  Log a message with the specified category, message, priority, and additional information.
    ///
    /// - Parameters:
    ///   - category: The category of the log.
    ///   - message: The log message.
    ///   - level: The priority level of the log.
    ///   - file: The file path. By default, it is automatically filled with the calling file path.
    ///   - function: The function name. By default, it is automatically filled with the calling function name.
    ///   - line: The line number. By default, it is automatically filled with the calling line number.
    ///   - appendToFile: Specify if you want to add it to log.txt file.
    public static func log(
        for category: Categories,
        with message: String,
        priority level: OSLogType,
        file: String = #file,
        function: String = #function,
        line: Int = #line,
        appendToFile: Bool = false
    ) {
        let _ = sharedInstance
        let logTime = dateFormatter.string(from: Date())
        let logMessage = "\(iconForCategory(category)) [\(logTime)][\(URL(fileURLWithPath: file).deletingPathExtension().lastPathComponent) on line: \(line)] - \(function)\n LOG MESSAGE:\n\(message)"
        
        let logger = getLogger(for: category)
        
        switch level {
        case .fault:
            logger.critical("\(logMessage)")
            
        case .error:
            logger.error("\(logMessage)")
            
        case .debug:
            logger.debug("\(logMessage)")
            
        case .default:
            logger.log("\(logMessage)")
            
        case .info:
            logger.info("\(logMessage)")
            
        default:
            logger.log("\(logMessage)")
        }
        
        if appendToFile {
            writeLogToFile(log: logMessage, for: category)
        }
    }
    /// Write log message into log.txt file with the specified category, message, priority, and additional information.
    ///
    /// - Parameters:
    ///   - log: Content of the log file.
    private static func writeLogToFile(log: String, for category: Categories) {
#if DEBUG
        guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            self.log(for: .privateFileLogging, with: "Log file (log.txt) not found", priority: .error)
            return
        }
        
        let logFileURL = documentsDirectory.appendingPathComponent("\(category.rawValue).txt")
        
        do {
            let textToWrite = "\(log)\n"
            
            if let fileHandle = FileHandle(forWritingAtPath: logFileURL.path) {
                fileHandle.seekToEndOfFile()
                fileHandle.write(textToWrite.data(using: .utf8)!)
                fileHandle.closeFile()
            } else {
                try textToWrite.write(to: logFileURL, atomically: true, encoding: .utf8)
            }
            
            self.log(for: .privateFileLogging, with: "Log successfully appended to file \(logFileURL)", priority: .default)

        } catch {
            self.log(for: .privateFileLogging, with: "Failed to write log to file: \(error.localizedDescription)", priority: .error)
        }
#endif
    }
    /// Check contents of log.txt file.
    ///
    private static func checkFileContent() {
        guard let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first?.appendingPathComponent("log.txt") else {
            log(for: .privateFileLogging, with: "Log file (log.txt) not found", priority: .error)
            return
        }
        
        do {
            let fileContent = try String(contentsOf: fileURL, encoding: .utf8)
            log(for: .privateFileLogging, with: "Log file content:\n\(fileContent)", priority: .default)

        } catch {
            log(for: .privateFileLogging, with: "Error reading log file content: \(error.localizedDescription)", priority: .error)
        }
    }
    
    internal static func iconForCategory(_ category: Categories) -> String {
        switch category {
        case .viewcycleLogging:
            return "üîÑ"
        case .userInterfaceLogging:
            return "‚öôÔ∏è"
        case .networkLogging:
            return "üåê"
        case .statisticsLogging:
            return "üìä"
        case .privateFileLogging:
            return "‚ôøÔ∏è"
        case .socketLogging:
            return "üì∂"
        }
    }
}

public enum Categories: String {
    /// - viewcycleLogging: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤ –∏–ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
    case viewcycleLogging = "viewcycleLogging"
    /// - userInterfaceLogging: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.
    case userInterfaceLogging = "userInterfaceLogging"
    /// - networkLogging: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π —Å–µ—Ç–µ–≤–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è.
    case networkLogging = "networkLogging"
    /// - statisticsLogging: –û–±—â–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –Ω–µ—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.
    case statisticsLogging = "statisticsLogging"
    /// - privateFileLogging: –ü—Ä–∏–≤–∞—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–∏—Å–∏/—á—Ç–µ–Ω–∏—è –ª–æ–≥–æ–≤ –≤ —Ñ–∞–π–ª.
    case privateFileLogging = "privateFileLogging"
    /// - privateFileLogging: –ü—Ä–∏–≤–∞—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–∏—Å–∏/—á—Ç–µ–Ω–∏—è –ª–æ–≥–æ–≤ –≤ —Ñ–∞–π–ª.
    case socketLogging = "socketLogging"
}
//
//extension Logger {
//    /// –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –ª–æ–≥-—Ñ–∞–π–ª–æ–≤ –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
//    public enum Categories: String {
//        /// - viewcycleLogging: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤ –∏–ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
//        case viewcycleLogging = "viewcycleLogging"
//        /// - userInterfaceLogging: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.
//        case userInterfaceLogging = "userInterfaceLogging"
//        /// - networkLogging: –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π —Å–µ—Ç–µ–≤–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è.
//        case networkLogging = "networkLogging"
//        /// - statisticsLogging: –û–±—â–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –Ω–µ—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.
//        case statisticsLogging = "statisticsLogging"
//        /// - privateFileLogging: –ü—Ä–∏–≤–∞—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–∏—Å–∏/—á—Ç–µ–Ω–∏—è –ª–æ–≥–æ–≤ –≤ —Ñ–∞–π–ª.
//        case privateFileLogging = "privateFileLogging"
//    }
//    /// –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –±–∞–Ω–¥–ª–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –≤ Console.app.
//    private static var subsystem = Bundle.main.bundleIdentifier!
//    /// –§–æ—Ä–º–∞—Ç—Ç–µ—Ä –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –ª–æ–≥ —Ñ–∞–π–ª–∞.
//    private static let dateFormatter: DateFormatter = {
//        let formatter = DateFormatter()
//        formatter.dateFormat = "HH:mm:ss"
//        return formatter
//    }()
//    /// Log a message with the specified category, message, priority, and additional information.
//    ///
//    /// - Parameters:
//    ///   - category: The category of the log.
//    ///   - message: The log message.
//    ///   - level: The priority level of the log.
//    ///   - file: The file path. By default, it is automatically filled with the calling file path.
//    ///   - function: The function name. By default, it is automatically filled with the calling function name.
//    ///   - line: The line number. By default, it is automatically filled with the calling line number.
//    ///   - appendToFile: Specify if you want to add it to log.txt file.
//    public static func log(
//        for category: Categories,
//        with message: String,
//        priority level: OSLogType,
//        file: String = #file,
//        function: String = #function,
//        line: Int = #line,
//        appendToFile: Bool = false
//    ) {
//        let logTime = dateFormatter.string(from: Date())
//        let logMessage = "\(iconForCategory(category)) [\(logTime)][\(URL(fileURLWithPath: file).deletingPathExtension().lastPathComponent) on line: \(line)] - \(function)\n LOG MESSAGE:\n\(message)"
//        os_log("%{public}@", log: OSLog(subsystem: subsystem, category: category.rawValue), type: level, logMessage)
//        if appendToFile {
//            writeLogToFile(log: logMessage)
//            checkFileContent()
//        }
//    }
//    /// Write log message into log.txt file with the specified category, message, priority, and additional information.
//    ///
//    /// - Parameters:
//    ///   - log: Content of the log file.
//    private static func writeLogToFile(log: String) {
//#if DEBUG
//        guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
//            self.log(for: .privateFileLogging, with: "Log file (log.txt) not found", priority: .error)
//            return
//        }
//        
//        let logFileURL = documentsDirectory.appendingPathComponent("log.txt")
//        
//        do {
//            let textToWrite = "\(log)\n"
//            
//            if let fileHandle = FileHandle(forWritingAtPath: logFileURL.path) {
//                fileHandle.seekToEndOfFile()
//                fileHandle.write(textToWrite.data(using: .utf8)!)
//                fileHandle.closeFile()
//            } else {
//                try textToWrite.write(to: logFileURL, atomically: true, encoding: .utf8)
//            }
//            
////            self.log(for: .privateFileLogging, with: "Log successfully appended to file", priority: .default)
//
//        } catch {
//            self.log(for: .privateFileLogging, with: "Failed to write log to file: \(error.localizedDescription)", priority: .error)
//        }
//#endif
//    }
//    /// Check contents of log.txt file.
//    ///
//    private static func checkFileContent() {
//        guard let fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first?.appendingPathComponent("log.txt") else {
//            log(for: .privateFileLogging, with: "Log file (log.txt) not found", priority: .error)
//            return
//        }
//        
//        do {
//            let fileContent = try String(contentsOf: fileURL, encoding: .utf8)
//            log(for: .privateFileLogging, with: "Log file content:\n\(fileContent)", priority: .default)
//
//        } catch {
//            log(for: .privateFileLogging, with: "Error reading log file content: \(error.localizedDescription)", priority: .error)
//        }
//    }
//    /// Clears log file (log.txt).
//    ///
//    public static func clearLogFile() {
//        guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
//            log(for: .privateFileLogging, with: "Log file (log.txt) not found", priority: .error)
//            return
//        }
//        
//        let logFileURL = documentsDirectory.appendingPathComponent("log.txt")
//        
//        do {
//            try FileManager.default.removeItem(at: logFileURL)
//            log(for: .privateFileLogging, with: "Log file cleared successfully", priority: .default)
//        } catch {
//            log(for: .privateFileLogging, with: "Failed to clear log file: \(error.localizedDescription)", priority: .default)
//        }
//    }
//
//    /// Add icon to log depending on selected category.
//    ///
//    /// - Parameters:
//    ///   - category: The category of the log.
//    ///
//    /// - Returns:
//    ///  Returns icon according to log type.
//    internal static func iconForCategory(_ category: Categories) -> String {
//        switch category {
//        case .viewcycleLogging:
//            return "üîÑ"
//        case .userInterfaceLogging:
//            return "‚öôÔ∏è"
//        case .networkLogging:
//            return "üåê"
//        case .statisticsLogging:
//            return "üìä"
//        case .privateFileLogging:
//            return "‚ôøÔ∏è"
//        }
//    }
//}
